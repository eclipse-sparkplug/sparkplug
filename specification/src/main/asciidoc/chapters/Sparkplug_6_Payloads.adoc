////
Copyright © 2016-2021 The Eclipse Foundation, Cirrus Link Solutions, and others

This program and the accompanying materials are made available under the
terms of the Eclipse Public License v. 2.0 which is available at
https://www.eclipse.org/legal/epl-2.0.

SPDX-License-Identifier: EPL-2.0

_Sparkplug™ and the Sparkplug™ logo are trademarks of the Eclipse Foundation_
////

[[payloads]]
== Payloads

[[payloads_overview]]
=== Overview

The MQTT message transport specification does not define any required data payload format. From an MQTT 
infrastructure standpoint, the payload is treated as an agnostic binary array of bytes that can be anything 
from no payload at all, to a maximum of 256MB. But for applications within a known solution space to work 
using MQTT the payload representation does need to be defined.

This section of the Sparkplug™ specification defines how an MQTT Sparkplug payloads are encoded and the data 
that is required. Note that Sparkplug supports multiple payloads encoding definitions. For more detailed 
information on the payload formats and encoding associated with each Sparkplug release see the following 
sections.

.. Sparkplug A Data Spec (TODO)
.. Sparkplug B Data Spec (TODO)

The majority of devices connecting into next generation IIoT infrastructure are legacy equipment using 
poll/response protocols. This means we must take in account register based data from devices that talk 
protocols like Modbus. The existing legacy equipment needs to work in concert with emerging IIoT equipment 
that is able to leverage message transports like MQTT natively.

[[payloads_google_protocol_buffers]]
=== Google Protocol Buffers

*_"Protocol Buffers are a way of encoding structured data in an efficient yet extensible format."_*

Google Protocol Buffers, sometimes referred to as "*Google Protobufs*", provide the efficiency of packed 
binary data encoding while providing the structure required to make it easy to create, transmit, and parse 
register based process variables using a standard set of tools while enabling emerging IIoT requirements 
around richer metadata. Google Protocol Buffers development tools are available for:

* C
* C++
* C#
* Java
* Python
* GO
* JavaScript

Additional information on Google Protocol Buffers can be found at:

https://developers.google.com/protocol-buffers/

[[payloads_sparkplug_a_mqtt_payload_definition]]
=== Sparkplug A MQTT Payload Definition
TODO: Github Issue #55

[[payloads_sparkplug_b_mqtt_payload_definition]]
=== Sparkplug B MQTT Payload Definition

The goal of the Sparkplug is to provide a specification that both OEM device manufactures and application 
developers can use to create rich and interoperable SCADA/IIoT solutions using MQTT as a base messaging 
technology. In Sparkplug B message payload definition, the goal was to create a simple and straightforward 
binary message encoding that could be used primarily for legacy register based process variables (Modbus 
register value for example).

The Sparkplug B MQTT payload specification has come about based on the feedback from many system integrators 
and end user customers who wanted to be able to natively support a much richer data model within the MQTT 
infrastructures that they were designing and deploying. Using the feedback from the user community 
Sparkplug B provides support for:

* Complex data types using templates.
* Datasets.
* Richer metrics with the ability to add property metadata for each metric.
* Metric alias support to maintain rich metric naming while keeping bandwidth usage to a minimum.
* Historical data.
* File data.

Sparkplug B definition creates a bandwidth efficient data transport for real time device data. For WAN based 
SCADA/IIoT infrastructures this equates to lower latency data updates while minimizing the amount of traffic 
and therefore cellular and/or VSAT bandwidth required. In situations where bandwidth savings is not the 
primary concern, the efficient use enables higher throughput of more and interesting data eliminating sensor 
data that have been left stranded in the field. It is also ideal for LAN based SCADA infrastructures equating 
to higher throughput of real time data to consumer applications without requiring extreme networking 
topologies and/or equipment.

There are many data encoding technologies available that can all be used in conjunction with MQTT. 
Sparkplug B selected an existing, open, and highly available encoding scheme that efficiently encodes 
register based process variables. The encoding technology selected for Sparkplug B is Google Protocol 
Buffers also referred to as *Google* *_Protobufs_*.

[[payloads_google_protocol_buffer_schema]]
==== Google Protocol Buffer Schema

Using lessons learned on the feedback from the Sparkplug A implementation a new Google Protocol Buffer 
schema was developed that could be used to represent and encode the more complex data models being 
requested. The entire Google Protocol Buffers definition is below.

----
// * Copyright (c) 2015, 2018 Cirrus Link Solutions and others
// *
// * This program and the accompanying materials are made available under the
// * terms of the Eclipse Public License 2.0 which is available at
// * http://www.eclipse.org/legal/epl-2.0.
// *
// * SPDX-License-Identifier: EPL-2.0
// *
// * Contributors:
// *   Cirrus Link Solutions - initial implementation

//
// To compile:
// cd client_libraries/java
// protoc --proto_path=../../ --java_out=src/main/java ../../sparkplug_b.proto 
//

syntax = "proto2";

package org.eclipse.tahu.protobuf;

option java_package         = "org.eclipse.tahu.protobuf";
option java_outer_classname = "SparkplugBProto";

message Payload {
    /*
        // Indexes of Data Types

        // Unknown placeholder for future expansion.
        Unknown         = 0;

        // Basic Types
        Int8            = 1;
        Int16           = 2;
        Int32           = 3;
        Int64           = 4;
        UInt8           = 5;
        UInt16          = 6;
        UInt32          = 7;
        UInt64          = 8;
        Float           = 9;
        Double          = 10;
        Boolean         = 11;
        String          = 12;
        DateTime        = 13;
        Text            = 14;

        // Additional Metric Types
        UUID            = 15;
        DataSet         = 16;
        Bytes           = 17;
        File            = 18;
        Template        = 19;

        // Additional PropertyValue Types
        PropertySet     = 20;
        PropertySetList = 21;
    */

    message Template {

        message Parameter {
            optional string name        = 1;
            optional uint32 type        = 2;

            oneof value {
                uint32 int_value        = 3;
                uint64 long_value       = 4;
                float  float_value      = 5;
                double double_value     = 6;
                bool   boolean_value    = 7;
                string string_value     = 8;
                ParameterValueExtension extension_value = 9;
            }

            message ParameterValueExtension {
                extensions              1 to max;
            }
        }

        optional string version         = 1;          // The version of the Template to prevent mismatches
        repeated Metric metrics         = 2;          // Each metric includes a name, datatype, and optionally a value
        repeated Parameter parameters   = 3;
        optional string template_ref    = 4;          // Reference to a template if this is extending a Template or an instance - must exist if an instance
        optional bool is_definition     = 5;
        extensions                      6 to max;
    }

    message DataSet {

        message DataSetValue {

            oneof value {
                uint32 int_value                        = 1;
                uint64 long_value                       = 2;
                float  float_value                      = 3;
                double double_value                     = 4;
                bool   boolean_value                    = 5;
                string string_value                     = 6;
                DataSetValueExtension extension_value   = 7;
            }

            message DataSetValueExtension {
                extensions  1 to max;
            }
        }

        message Row {
            repeated DataSetValue elements  = 1;
            extensions                      2 to max;   // For third party extensions
        }

        optional uint64   num_of_columns    = 1;
        repeated string   columns           = 2;
        repeated uint32   types             = 3;
        repeated Row      rows              = 4;
        extensions                          5 to max;   // For third party extensions
    }

    message PropertyValue {

        optional uint32     type                    = 1;
        optional bool       is_null                 = 2; 

        oneof value {
            uint32          int_value               = 3;
            uint64          long_value              = 4;
            float           float_value             = 5;
            double          double_value            = 6;
            bool            boolean_value           = 7;
            string          string_value            = 8;
            PropertySet     propertyset_value       = 9;
            PropertySetList propertysets_value      = 10;      // List of Property Values
            PropertyValueExtension extension_value  = 11;
        }

        message PropertyValueExtension {
            extensions                             1 to max;
        }
    }

    message PropertySet {
        repeated string        keys     = 1;         // Names of the properties
        repeated PropertyValue values   = 2;
        extensions                      3 to max;
    }

    message PropertySetList {
        repeated PropertySet propertyset = 1;
        extensions                       2 to max;
    }

    message MetaData {
        // Bytes specific metadata
        optional bool   is_multi_part   = 1;

        // General metadata
        optional string content_type    = 2;        // Content/Media type
        optional uint64 size            = 3;        // File size, String size, Multi-part size, etc
        optional uint64 seq             = 4;        // Sequence number for multi-part messages

        // File metadata
        optional string file_name       = 5;        // File name
        optional string file_type       = 6;        // File type (i.e. xml, json, txt, cpp, etc)
        optional string md5             = 7;        // md5 of data

        // Catchalls and future expansion
        optional string description     = 8;        // Could be anything such as json or xml of custom properties
        extensions                      9 to max;
    }

    message Metric {

        optional string   name          = 1;        // Metric name - should only be included on birth
        optional uint64   alias         = 2;        // Metric alias - tied to name on birth and included in all later DATA messages
        optional uint64   timestamp     = 3;        // Timestamp associated with data acquisition time
        optional uint32   datatype      = 4;        // DataType of the metric/tag value
        optional bool     is_historical = 5;        // If this is historical data and should not update real time tag
        optional bool     is_transient  = 6;        // Tells consuming clients such as MQTT Engine to not store this as a tag
        optional bool     is_null       = 7;        // If this is null - explicitly say so rather than using -1, false, etc for some datatypes.
        optional MetaData metadata      = 8;        // Metadata for the payload
        optional PropertySet properties = 9;

        oneof value {
            uint32   int_value                      = 10;
            uint64   long_value                     = 11;
            float    float_value                    = 12;
            double   double_value                   = 13;
            bool     boolean_value                  = 14;
            string   string_value                   = 15;
            bytes    bytes_value                    = 16;       // Bytes, File
            DataSet  dataset_value                  = 17;
            Template template_value                 = 18;
            MetricValueExtension extension_value    = 19;
        }

        message MetricValueExtension {
            extensions  1 to max;
        }
    }

    optional uint64   timestamp     = 1;        // Timestamp at message sending time
    repeated Metric   metrics       = 2;        // Repeated forever - no limit in Google Protobufs
    optional uint64   seq           = 3;        // Sequence number
    optional string   uuid          = 4;        // UUID to track message type in terms of schema definitions
    optional bytes    body          = 5;        // To optionally bypass the whole definition above
    extensions                      6 to max;   // For third party extensions
}
----

[[payloads_payload_metric_naming_convention]]
=== Payload Metric Naming Convention

For the remainder of this document JSON will be used to represent components of a Sparkplug B payload. It 
is important to note that the payload is a binary encoding and is not actually JSON. However, JSON 
representation is used in this document to represent the payloads in a way that is easy to read. For 
example, a simple Sparkplug B payload with a single metric can be represented in JSON as follows:

----
{
        "timestamp": <timestamp>,
        "metrics": [{
                "name": <metric_name>,
                "alias": <alias>,
                "timestamp": <timestamp>,
                "dataType": <datatype>,
                "value": <value>
        }],
        "seq": <sequence_number>
}
----

A simple Sparkplug B payload with values would be represented as follows:

----
{
        "timestamp": 1486144502122,
        "metrics": [{
                "name": "My Metric",
                "alias": 1,
                "timestamp": 1479123452194,
                "dataType": "String",
                "value": "Test"
        }],
        "seq": 2
}
----

Note that the ‘name’ of a metric may be hierarchical to build out proper folder structures for applications 
consuming the metric values. For example, in an application where an EoN node in connected to several 
devices or data sources, the ‘name’ could represent discrete folder structures of:

‘Metric Level 1/Metric Level 2/Metric Name’

Using this convention in conjunction with the *group_id*, *edge_node_id* and *device_id* already defined in 
the Topic Namespace, consuming applications can organize metrics in the same hierarchical fashion:

image:extracted-media/media/image12.png[image,width=638,height=139]

Figure 8 – Payload Metric Folder Structure

[[payloads_sparkplug_bv1_0_payload_components]]
== Sparkplug Bv1.0 Payload Components

The Sparkplug specification document “*_MQTT Topic Namespace and State Management_*” document defines the 
Topic Namespace that Sparkplug uses to publish and subscribe between EoN nodes and applications within the 
MQTT infrastructure. Using that Topic Namespace, this section of the specification defines the actual 
payload contents of each message type in Sparkplug Bv1.0.

[[payloads_payload_component_definitions]]
=== Payload Component Definitions

Sparkplug B consists of a series of one or more metrics with metadata surrounding those metrics. The 
following definitions explain the components that make up a payload.

[[payloads_payload]]
==== Payload

A Sparkplug B payload is the top-level component that is encoded and used in an MQTT message. It contains 
some basic information such as a timestamp and a sequence number as well as an array of metrics which 
contain key/value pairs of data. A Sparkplug B payload includes the following components.

* *payload*
** _timestamp_
*** This is the timestamp in the form of an unsigned 64-bit integer representing the number of milliseconds 
since epoch (Jan 1, 1970). It is highly recommended that this time is in UTC. This timestamp is meant to 
represent the time at which the message was published.
** _metrics_
*** This is an array of metrics representing key/value/datatype values. Metrics are further defined in 
section 3.1.2.
** _seq_
*** This is the sequence number which is an unsigned 64-bit integer. A sequence number must be included in 
the payload of every Sparkplug MQTT message. A NBIRTH message must always contain a sequence number of 
zero. All subsequent messages must contain a sequence number that is continually increasing by one in each 
message until a value of 255 is reached. At that point, the sequence number of the following message must 
be zero.
** _uuid_
*** This is a field which can be used to represent a schema or some other specific form of the message. 
Example usage would be to supply a UUID which represents an encoding mechanism of the optional array of 
bytes associated with a payload.
** _body_
*** This is an array of bytes which can be used for any custom binary encoded data.

[[payloads_metric]]
==== Metric

A Sparkplug B metric is a core component of data in the payload. It represents a key/value/datatype along 
with metadata used to describe the information it contains. It includes the following components.

* *name*
** This is the friendly name of a metric. It should be represented as a slash delimited UTF-8 string. The 
slashes in the string represent folders of the metric to represent hierarchical data structures. For 
example, ‘outputs/A’ would be a metric with a unique identifier of ‘A’ in the ‘outputs’ folder. There is no 
limit to the number of folders. However, across the infrastructure of MQTT publishers a defined folder 
should always remain a folder.
* *alias*
** This is an unsigned 64-bit integer representing an optional alias for a Sparkplug B payload. If supplied 
in an NBIRTH or DBIRTH it must be a unique number across this EoN nodes entire set of metrics. In other 
words, no two metrics for the same EoN node can have the same alias. Upon being defined in the NBIRTH or 
DBIRTH, subsequent messages can supply only the alias instead of the metric friendly name to reduce overall 
message size.
* *timestamp*
** This is the timestamp in the form of an unsigned 64-bit integer representing the number of milliseconds 
since epoch (Jan 1, 1970). It is highly recommended that this time is in UTC. This timestamp is meant to 
represent the time at which the value of a metric was captured.
* *datatype*
** This is an unsigned 32-bit integer representing the datatype. Datatypes are not explicitly defined in 
the Sparkplug B Protobuf definition. Instead they are defined in section 4 of this document.
* *is_historical*
** This is a Boolean flag which denotes whether this metric represents a historical value. In some cases, 
it may be desirable to send metrics after they were acquired on a device or EoN node. This can be done for 
batching, store and forward, or sending local backup data during network communication loses. This flag 
denotes that the message should not be considered a real time/current value.
* *is_transient*
** This is a Boolean flag which denotes whether this metric should be considered transient. Transient 
metrics can be considered those that are of interest to a back-end application(s) but shouldn’t be stored 
in a historian on the backend.
* *is_null*
** This is a Boolean flag which denotes whether this metric has a null value. This is Sparkplug B’s 
mechanism of explicitly denoting a metric’s value is actually null.
* *metadata*
** This is a MetaData object associated with the metric for dealing with more complex datatypes. This is 
covered in section 3.1.3 of this document.
* *properties*
** This is a PropertySet object associated with the metric for including custom key/value pairs of metadata 
associated with a metric. This is covered in section 3.1.4 of this document.
* *value*
** The value of a metric utilizes the ‘oneof’ mechanism of Google Protocol Buffers. The value supplied with 
a metric must be one of the following types. Note if the metrics is_null flag is set to true the value can 
be omitted altogether.
*** _uint32_
**** Defined here: https://developers.google.com/protocol-buffers/docs/proto#scalar
*** _uint64_
**** Defined here: https://developers.google.com/protocol-buffers/docs/proto#scalar
*** _float_
**** Defined here: https://developers.google.com/protocol-buffers/docs/proto#scalar
*** _double_
**** Defined here: https://developers.google.com/protocol-buffers/docs/proto#scalar
*** _bool_
**** Defined here: https://developers.google.com/protocol-buffers/docs/proto#scalar
*** _string_
**** Defined here: https://developers.google.com/protocol-buffers/docs/proto#scalar
*** _bytes_
**** Defined here: https://developers.google.com/protocol-buffers/docs/proto#scalar
*** _DataSet_
**** Defined in section 3.1.7 of this document.
*** _Template_
**** Defined in section 3.1.10 of this document.

[[payloads_metadata]]
==== MetaData

A Sparkplug B MetaData object is used to describe different types of binary data. It includes the 
following components.

* *is_multi_part*
** A Boolean representing whether this metric contains part of a multi-part message. Breaking up large 
quantities of data can be useful for keeping the flow of MQTT messages flowing through the system. Because 
MQTT requires in order delivery publishing very large messages can result in messages being blocked while 
delivery of large messages takes place.
* *content_type*
** This is a UTF-8 string which represents the content type of a given metric value.
* *size*
** This is an unsigned 64-bit integer representing the size of the metric value
* *seq*
** If this is a multipart metric, this is an unsigned 64-bit integer representing the sequence number of 
this part of a multipart metric.
* *file_name*
** If this is a file metric, this is a UTF-8 string representing the filename of the file.
* *file_type*
** If this is a file metric, this is a UTF-8 string representing the type of the file.
* *md5*
** If this is a byte array metric that can have a md5sum, this field can be used as a UTF-8 string to 
represent it.
* *description*
** This is a freeform field with a UTF-8 string to represent any other pertinent metadata for this metric. 
It can contain JSON, XML, text, or anything else that can be understood by both the publisher and the 
subscriber.

[[payloads_propertyset]]
==== PropertySet

A Sparkplug B PropertySet object is used with a metric to add custom properties to the object. The 
PropertySet is a map expressed as two arrays of equal size, one containing the keys and one containing the 
values. It includes the following components.

* *keys*
** This is an array of UTF-8 strings representing the names of the properties in this PropertySet. It must 
contain the same number of values included in the array of PropertyValue objects.
* *values*
** This is an array of PropertyValue objects representing the values of the properties in the PropertySet. 
It must contain the same number of items that are in the keys array.

[[payloads_propertyvalue]]
==== PropertyValue

A Sparkplug B PropertyValue object is used to encode the value and datatype of the value of a property in 
a PropertySet. It includes the following components.

* *type*
** This is an unsigned 32-bit integer representing the datatype of the value. Datatypes are not explicitly 
defined in the Sparkplug B Protobuf definition. Instead they are defined in section 4 of this document.
* *is_null*
** This is a Boolean flag which denotes whether this property has a null value. This is Sparkplug B’s 
mechanism of explicitly denoting a property’s value is actually null.
* *value*
** The value of a property utilizes the ‘oneof’ mechanism of Google Protocol Buffers. The value supplied 
with a metric must be one of the following types. Note if the metrics is_null flag is set to true the value 
can be omitted altogether.
*** _uint32_
**** Defined here: https://developers.google.com/protocol-buffers/docs/proto#scalar
*** _uint64_
**** Defined here: https://developers.google.com/protocol-buffers/docs/proto#scalar
*** _float_
**** Defined here: https://developers.google.com/protocol-buffers/docs/proto#scalar
*** _double_
**** Defined here: https://developers.google.com/protocol-buffers/docs/proto#scalar
*** _bool_
**** Defined here: https://developers.google.com/protocol-buffers/docs/proto#scalar
*** _string_
**** Defined here: https://developers.google.com/protocol-buffers/docs/proto#scalar
*** _PropertySet_
**** Defined in section 3.1.4 of this document.
*** _PropertySetList_
**** Defined in section 3.1.6 of this document

[[payloads_propertysetlist]]
==== PropertySetList

A Sparkplug B PropertySetList object is an array of PropertySet objects. It includes the following 
components.

* *propertyset*
** This is an array of PropertySet objects

[[payloads_dataset]]
==== DataSet

A Sparkplug B DataSet object is used to encode matrices of data. It includes the following components.

* *num_of_columns*
** This is an unsigned 64-bit integer representing the number of columns in this DataSet.
* *columns*
** This is an array of strings representing the column headers of this DataSet. It must have the same number 
of elements that the types array contains.
* *types*
** This is an array of unsigned 32 bit integers representing the datatypes of the columns. It must have the 
same number of elements that the columns array contains. Datatypes are not explicitly defined in the 
Sparkplug B Protobuf definition. Instead they are defined in section 4 of this document.
* *rows*
** This is an array of DataSet.Row objects. It contains the data that makes up the data rows of this 
DataSet.

[[payloads_dataset_row]]
==== DataSet.Row

A Sparkplug B DataSet.Row object represents a row of data in a DataSet. It includes the following 
components.

* *elements*
** This is an array of DataSet.DataSetValue objects. It represents the data contained within a row of a 
DataSet.

[[payloads_dataset_datasetvalue]]
==== DataSet.DataSetValue

* *value*
** The value of a DataSet.DataSetValue utilizes the ‘oneof’ mechanism of Google Protocol Buffers. The value 
supplied with a DataSet.DataSetValue must be one of the following types.
*** _uint32_
**** Defined here: https://developers.google.com/protocol-buffers/docs/proto#scalar
*** _uint64_
**** Defined here: https://developers.google.com/protocol-buffers/docs/proto#scalar
*** _float_
**** Defined here: https://developers.google.com/protocol-buffers/docs/proto#scalar
*** _double_
**** Defined here: https://developers.google.com/protocol-buffers/docs/proto#scalar
*** _bool_
**** Defined here: https://developers.google.com/protocol-buffers/docs/proto#scalar
*** _string_
**** Defined here: https://developers.google.com/protocol-buffers/docs/proto#scalar

[[payloads_template]]
==== Template

A Sparkplug B Template is used for encoding complex datatypes in a payload. It is a type of metric and can 
be used to create custom datatype definitions and instances. It includes the following components.

* *version*
** This is a UTF-8 string representing the version of the Template.
* *metrics*
** This is an array of metrics representing the members of the Template. These can be primitive datatypes 
or other complex datatypes as required for the Template.
* *parameters*
** This is an array of Parameter objects representing parameters associated with the Template.
* *template_ref*
** This is a UTF-8 string representing a reference to a Template name if this is a Template instance. If 
this is a Template definition this field must be null.
* *is_definition*
** This is a Boolean representing whether this is a Template definition or a Template instance. If true, 
this is a definition. If false, this is an instance.

[[payloads_template_parameter]]
==== Template.Parameter

A Sparkplug B Template.Parameter is a metadata field for a Template. This can be used to represent 
parameters that are common across a Template but the values are unique to the Template instances. It 
includes the following components.

* *name*
** This is a UTF-8 string representing the name of the Template parameter.
* *type*
** This is an unsigned 32-bit integer representing the datatype of the template parameter. Datatypes are 
not explicitly defined in the Sparkplug B Protobuf definition. Instead they are defined in section 4 of 
this document.
* *value*
** The value of a template parameter utilizes the ‘oneof’ mechanism of Google Protocol Buffers. The value 
supplied must be one of the following types. For a template definition, this is the default value of the 
parameter. For a template instance, this is the value unique to that instance.
*** _uint32_
**** Defined here: https://developers.google.com/protocol-buffers/docs/proto#scalar
*** _uint64_
**** Defined here: https://developers.google.com/protocol-buffers/docs/proto#scalar
*** _float_
**** Defined here: https://developers.google.com/protocol-buffers/docs/proto#scalar
*** _double_
**** Defined here: https://developers.google.com/protocol-buffers/docs/proto#scalar
*** _bool_
**** Defined here: https://developers.google.com/protocol-buffers/docs/proto#scalar
*** _string_
**** Defined here: https://developers.google.com/protocol-buffers/docs/proto#scalar

[[payloads_sparkplug_bv1_0_payload_datatypes]]
=== Sparkplug Bv1.0 Payload Datatypes

The Sparkplug B Google Protocol Buffers definition intentionally excludes datatypes in the definition. 
Different applications and systems have a wide variety of datatypes. As a result, Sparkplug B left them 
out and instead defines them in the client libraries. This allows consuming applications to be more dynamic 
in terms of adding new datatypes or even defining custom datatypes.

[[payloads_metric_datatypes]]
==== Metric Datatypes

* *Basic Types*
** _Unknown_
*** Sparkplug enum value: 0
** _Int8_
*** Signed 8-bit integer
*** Google Protocol Buffer Type: uint32
*** Sparkplug enum value: 1
** _Int16_
*** Signed 16-bit integer
*** Google Protocol Buffer Type: uint32
*** Sparkplug enum value: 2
** _Int32_
*** Signed 32-bit integer
*** Google Protocol Buffer Type: uint32
*** Sparkplug enum value: 3
** _Int64_
*** Signed 64-bit integer
*** Google Protocol Buffer Type: uint64
*** Sparkplug enum value: 4
** _UInt8_
*** Unsigned 8-bit integer
*** Google Protocol Buffer Type: uint32
*** Sparkplug enum value: 5
** _UInt16_
*** Unsigned 16-bit integer
*** Google Protocol Buffer Type: uint32
*** Sparkplug enum value: 6
** _UInt32_
*** Unsigned 32-bit integer
*** Google Protocol Buffer Type: uint32
*** Sparkplug enum value: 7
** _UInt64_
*** Unsigned 64-bit integer
*** Google Protocol Buffer Type: uint64
*** Sparkplug enum value: 8
** _Float_
*** 32-bit floating point number
*** Google Protocol Buffer Type: float
*** Sparkplug enum value: 9
** _Double_
*** 64-bit floating point number
*** Google Protocol Buffer Type: double
*** Sparkplug enum value: 10
** _Boolean_
*** Boolean value
*** Google Protocol Buffer Type: bool
*** Sparkplug enum value: 11
** _String_
*** String value (UTF-8)
*** Google Protocol Buffer Type: string
*** Sparkplug enum value: 12
* _DateTime_
** Date time value as uint64 value representing milliseconds since epoch (Jan 1, 1970)
** Google Protocol Buffer Type: uint64
** Sparkplug enum value: 13
* _Text_
** String value (UTF-8)
** Google Protocol Buffer Type: string
** Sparkplug enum value: 14

* *Custom Types*
** _UUID_
*** UUID value as a UTF-8 string
*** Google Protocol Buffer Type: string
*** Sparkplug enum value: 15
** _DataSet_
*** DataSet as defined in section 3.1.7
*** Google Protocol Buffer Type: none – defined in Sparkplug
*** Sparkplug enum value: 16
** _Bytes_
*** Array of bytes
*** Google Protocol Buffer Type: bytes
*** Sparkplug enum value: 17
** _File_
*** Array of bytes representing a file
*** Google Protocol Buffer Type: bytes
*** Sparkplug enum value: 18
** _Template_
*** Template as defined in section 3.1.10
*** Google Protocol Buffer Type: none – defined in Sparkplug
*** Sparkplug enum value: 19

[[payloads_propertyvalue_datatypes]]
==== PropertyValue Datatypes

* *Basic Types*
** _Unknown_
*** Sparkplug enum value: 0
** _Int8_
*** Signed 8-bit integer
*** Google Protocol Buffer Type: uint32
*** Sparkplug enum value: 1
** _Int16_
*** Signed 16-bit integer
*** Google Protocol Buffer Type: uint32
*** Sparkplug enum value: 2
** _Int32_
*** Signed 32-bit integer
*** Google Protocol Buffer Type: uint32
*** Sparkplug enum value: 3
** _Int64_
*** Signed 64-bit integer
*** Google Protocol Buffer Type: uint64
*** Sparkplug enum value: 4
** _Uint8_
*** Unsigned 8-bit integer
*** Google Protocol Buffer Type: uint32
*** Sparkplug enum value: 5
** _Uint16_
*** Unsigned 16-bit integer
*** Google Protocol Buffer Type: uint32
*** Sparkplug enum value: 6
** _Uint32_
*** Unsigned 32-bit integer
*** Google Protocol Buffer Type: uint32
*** Sparkplug enum value: 7
** _Uint64_
*** Unsigned 64-bit integer
*** Google Protocol Buffer Type: uint64
*** Sparkplug enum value: 8
** _Float_
*** 32-bit floating point number
*** Google Protocol Buffer Type: float
*** Sparkplug enum value: 9
** _Double_
*** 64-bit floating point number
*** Google Protocol Buffer Type: double
*** Sparkplug enum value: 10
** _Boolean_
*** Boolean value
*** Google Protocol Buffer Type: bool
*** Sparkplug enum value: 11
** _String_
*** String value (UTF-8)
*** Google Protocol Buffer Type: string
*** Sparkplug enum value: 12
** _DateTime_
*** Date time value as uint64 value representing milliseconds since epoch (Jan 1, 1970)
*** Google Protocol Buffer Type: uint64
*** Sparkplug enum value: 13
** _Text_
*** String value (UTF-8)
*** Google Protocol Buffer Type: string
*** Sparkplug enum value: 14

* *Custom Types*
** _PropertySet_
*** PropertySet as defined in section 3.1.4
*** Google Protocol Buffer Type: none – defined in Sparkplug
*** Sparkplug enum value: 20
** _PropertySetList_
*** Template as defined in section 3.1.6
*** Google Protocol Buffer Type: none – defined in Sparkplug
*** Sparkplug enum value: 21

[[payloads_datasetvalue_data_types]]
==== DataSetValue Data Types

* *Basic Types*
** _Unknown_
*** Sparkplug enum value: 0
** _Int8_
*** Signed 8-bit integer
*** Google Protocol Buffer Type: uint32
*** Sparkplug enum value: 1
** _Int16_
*** Signed 16-bit integer
*** Google Protocol Buffer Type: uint32
*** Sparkplug enum value: 2
** _Int32_
*** Signed 32-bit integer
*** Google Protocol Buffer Type: uint32
*** Sparkplug enum value: 3
** _Int64_
*** Signed 64-bit integer
*** Google Protocol Buffer Type: uint64
*** Sparkplug enum value: 4
** _Uint8_
*** Unsigned 8-bit integer
*** Google Protocol Buffer Type: uint32
*** Sparkplug enum value: 5
** _Uint16_
*** Unsigned 16-bit integer
*** Google Protocol Buffer Type: uint32
*** Sparkplug enum value: 6
** _Uint32_
*** Unsigned 32-bit integer
*** Google Protocol Buffer Type: uint32
*** Sparkplug enum value: 7
** _Uint64_
*** Unsigned 64-bit integer
*** Google Protocol Buffer Type: uint64
*** Sparkplug enum value: 8
** _Float_
*** 32-bit floating point number
*** Google Protocol Buffer Type: float
*** Sparkplug enum value: 9
** _Double_
*** 64-bit floating point number
*** Google Protocol Buffer Type: double
*** Sparkplug enum value: 10
** _Boolean_
*** Boolean value
*** Google Protocol Buffer Type: bool
*** Sparkplug enum value: 11
** _String_
*** String value (UTF-8)
*** Google Protocol Buffer Type: string
*** Sparkplug enum value: 12
** _DateTime_
*** Date time value as uint64 value representing milliseconds since epoch (Jan 1, 1970)
*** Google Protocol Buffer Type: uint64
*** Sparkplug enum value: 13
** _Text_
*** String value (UTF-8)
*** Google Protocol Buffer Type: string
*** Sparkplug enum value: 14

[[payloads_template_parameter_data_types]]
==== Template.Parameter Data Types

* *Basic Types*
** _Unknown_
*** Sparkplug enum value: 0
** _Int8_
*** Signed 8-bit integer
*** Google Protocol Buffer Type: uint32
*** Sparkplug enum value: 1
** _Int16_
*** Signed 16-bit integer
*** Google Protocol Buffer Type: uint32
*** Sparkplug enum value: 2
** _Int32_
*** Signed 32-bit integer
*** Google Protocol Buffer Type: uint32
*** Sparkplug enum value: 3
** _Int64_
*** Signed 64-bit integer
*** Google Protocol Buffer Type: uint64
*** Sparkplug enum value: 4
* _Uint8_
** Unsigned 8-bit integer
** Google Protocol Buffer Type: uint32
** Sparkplug enum value: 5
* _Uint16_
** Unsigned 16-bit integer
** Google Protocol Buffer Type: uint32
** Sparkplug enum value: 6
* _Uint32_
** Unsigned 32-bit integer
** Google Protocol Buffer Type: uint32
** Sparkplug enum value: 7
* _Uint64_
** Unsigned 64-bit integer
** Google Protocol Buffer Type: uint64
** Sparkplug enum value: 8
* _Float_
** 32-bit floating point number
** Google Protocol Buffer Type: float
** Sparkplug enum value: 9
* _Double_
** 64-bit floating point number
** Google Protocol Buffer Type: double
** Sparkplug enum value: 10
* _Boolean_
** Boolean value
** Google Protocol Buffer Type: bool
** Sparkplug enum value: 11
* _String_
** String value (UTF-8)
** Google Protocol Buffer Type: string
** Sparkplug enum value: 12
* _DateTime_
** Date time value as uint64 value representing milliseconds since epoch (Jan 1, 1970)
** Google Protocol Buffer Type: uint64
** Sparkplug enum value: 13
* _Text_
** String value (UTF-8)
** Google Protocol Buffer Type: string
** Sparkplug enum value: 14

[[payloads_payloads_by_message_type]]
== Payloads by Message Type

[[payloads_desc_nbirth]]
=== NBIRTH

The NBIRTH message requires the following payload components.

* The NBIRTH must include the a seq number in the payload and it must have a value of 0.
* The NBIRTH must include a timestamp denoting the DateTime the message was sent from the EoN node.
* The NBIRTH must include every metric the EoN node will ever report on. At a minimum these metrics must 
include:
** The metric name
** The metric datatype
** The current value
* If Template instances will be published by this EoN or any devices, all Template definitions must be 
published in the NBIRTH.
* A bdSeq number as a metric should be included in the payload. This should match the bdSeq number provided 
in the MQTT CONNECT packet’s LW&T payload. This allows backend applications to correlate NBIRTHs to NDEATHs. 
The bdSeq number should start at zero and increment by one on every new MQTT CONNECT.

The NBIRTH message can also include optional ‘Node Control’ payload components. These are used by a backend 
application to control aspects of the EoN node. The following are examples of Node Control metrics.

* Metric name: ‘Node Control/Reboot’
** Used by backend application(s) to reboot an EoN node.
* Metric name: ‘Node Control/Rebirth’
** Used by backend application(s) to request a new NBIRTH and DBIRTH(s) from an EoN node.
* Metric name: ‘Node Control/Next Server’
** Used by backend application(s) to request an EoN node to walk to the next MQTT Server in its list in 
multi-MQTT Server environments.
* Metric name: ‘Node Control/Scan rate’
** Used by backed application(s) to modify a poll rate on an EoN node.

The NBIRTH message can also include optional ‘Properties’ of an EoN node. The following are examples of 
Property metrics.

* Metric name: ‘Properties/Hardware Make’
** Used to transmit the hardware manufacturer of the EoN node
* Metric name: ‘Properties/Hardware Model’
** Used to transmit the hardware model of the EoN node
* Metric name: ‘Properties/OS’
** Used to transmit the operating system of the EoN node
* Metric name: ‘Properties/OS Version’
** Used to transmit the OS version of the EoN node

[[payloads_desc_dbirth]]
=== DBIRTH

The DBIRTH message requires the following payload components.

* The DBIRTH must include the a seq number in the payload and it must have a value of one greater than the 
previous MQTT message from the EoN node contained unless the previous MQTT message contained a value of 255. 
In this case the seq number must be 0.
* The DBIRTH must include a timestamp denoting the DateTime the message was sent from the EoN node.
* The DBIRTH must include every metric the device will ever report on. At a minimum these metrics must 
include:
** The metric name
** The metric datatype
** The current value

The DBIRTH message can also include optional ‘Device Control’ payload components. These are used by a 
backend application to control aspects of a device. The following are examples of Device Control metrics.

* Metric name: ‘Device Control/Reboot’
** Used by backend application(s) to reboot a device.
* Metric name: ‘Device Control/Rebirth’
** Used by backend application(s) to request a new DBIRTH from a device.
* Metric name: ‘Device Control/Scan rate’
** Used by backed application(s) to modify a poll rate on a device.

The DBIRTH message can also include optional ‘Properties’ of a device. The following are examples of 
Property metrics.

* Metric name: ‘Properties/Hardware Make’
** Used to transmit the hardware manufacturer of the device
* Metric name: ‘Properties/Hardware Model’
** Used to transmit the hardware model of the device
* Metric name: ‘Properties/FW’
** Used to transmit the firmware version of the device

[[payloads_desc_ndata]]
=== NDATA

The NDATA message requires the following payload components.

* The NDATA must include the a seq number in the payload and it must have a value of one greater than the 
previous MQTT message from the EoN node contained unless the previous MQTT message contained a value of 255. 
In this case the seq number must be 0.
* The NDATA must include a timestamp denoting the DateTime the message was sent from the EoN node.
* The NDATA must include the EoN node’s metrics that have changed since the last NBIRTH or NDATA message.

[[payloads_desc_ddata]]
=== DDATA

The DDATA message requires the following payload components.

* The DDATA must include the a seq number in the payload and it must have a value of one greater than the 
previous MQTT message from the EoN node contained unless the previous MQTT message contained a value of 255. 
In this case the seq number must be 0.
* The DDATA must include a timestamp denoting the DateTime the message was sent from the EoN node.
* The DDATA must include the device’s metrics that have changed since the last DBIRTH or DDATA message.

[[payloads_desc_ncmd]]
=== NCMD

The NCMD message requires the following payload components.

* The NCMD must include a timestamp denoting the DateTime the message was sent from the backend 
application’s MQTT client.
* The NCMD must include the metrics that need to be written to on the EoN node.

[[payloads_desc_dcmd]]
=== DCMD

The DCMD message requires the following payload components.

* The DCMD must include a timestamp denoting the DateTime the message was sent from the backend 
application’s MQTT client.
* The DCMD must include the metrics that need to be written to on the device.

[[payloads_desc_ddeath]]
=== DDEATH

The DDEATH message requires the following payload components.

* The DDEATH must include the a seq number in the payload and it must have a value of one greater than the 
previous MQTT message from the EoN node contained unless the previous MQTT message contained a value of 255. 
In this case the seq number must be 0.

[[payloads_desc_ndeath]]
=== NDEATH

The NDEATH message contains a very simple payload that only includes a single metric, the bdSeq number, so 
that the NDEATH event can be associated with the NBIRTH. Since this is typically published by the MQTT 
Server on behalf of the EoN node, information about the current state of the EoN node and its devices is 
not and cannot be known.

[[payloads_desc_state]]
=== STATE

The STATE messages from the primary host application must include a payload that is a UTF-8 string that is one 
of the following:

* OFFLINE
** If the application is not connected
* ONLINE
** If the application is connected

Sparkplug B payloads are not used for encoding in this payload. This allows primary host and host application(s) 
to work across Sparkplug payload types.

[[payloads_payload_representation_on_backend_applications]]
== Payload Representation on Backend Applications

Sparkplug B payloads in conjunction with the Sparkplug topic namespace result in hierarchical data 
structures that can be represented in folder structures with metrics which are often called tags.

[[payloads_nbirth]]
=== NBIRTH

The NBIRTH is responsible for informing the backend system of all of the information about the EoN node. 
This includes every metric it will publish data for in the future.

The following is a representation of a simple NBIRTH message on the topic:

spBv1.0/Sparkplug B Devices/NBIRTH/Raspberry Pi

In the topic above the following information is known based on the Sparkplug topic definition:

* The ‘Group ID’ of this EoN node is: Sparkplug B Devices
* The ‘EoN node ID’ of this EoN node is: Raspberry Pi
* * This is an NBIRTH message from the EoN node

Consider the following Sparkplug B payload in the NBIRTH message shown above:

----
{
        "timestamp": 1486144502122,
        "metrics": [{
                "name": "bdSeq",
                "timestamp": 1486144502122,
                "dataType": "Uint64",
                "value": 0
        }, {
                "name": "Node Control/Reboot",
                "timestamp": 1486144502122,
                "dataType": "Boolean",
                "value": false
        }, {
                "name": "Node Control/Rebirth",
                "timestamp": 1486144502122,
                "dataType": "Boolean",
                "value": false
        }, {
                "name": "Node Control/Next Server",
                "timestamp": 1486144502122,
                "dataType": "Boolean",
                "value": false
        }, {
                "name": "Node Control/Scan Rate",
                "timestamp": 1486144502122,
                "dataType": "Int64",
                "value": 3000
        }, {
                "name": "Properties/Hardware Make",
                "timestamp": 1486144502122,
                "dataType": "String",
                "value": "Raspberry Pi"
        }, {
                "name": "Properties/Hardware Model",
                "timestamp": 1486144502122,
                "dataType": "String",
                "value": "Pi 3 Model B"
        }, {
                "name": "Properties/OS",
                "timestamp": 1486144502122,
                "dataType": "String",
                "value": "Raspbian"
        }, {
                "name": "Properties/OS Version",
                "timestamp": 1486144502122,
                "dataType": "String",
                "value": "Jessie with PIXEL/11.01.2017"
        }, {
                "name": "Supply Voltage (V)",
                "timestamp": 1486144502122,
                "dataType": "Float",
                "value": 12.1
        }],
        "seq": 0
}
----

This would result in a structure as follows on the backend system.

image:extracted-media/media/image13.png[image,width=752,height=332]

Figure 9 – Sparkplug B Metric Structure 1

[[payloads_dbirth]]
=== DBIRTH

The DBIRTH is responsible for informing the backend system of all of the information about the device. This 
includes every metric it will publish data for in the future.

The following is a representation of a simple DBIRTH message on the topic:

spBv1.0/Sparkplug B Devices/DBIRTH/Raspberry Pi/Pibrella

In the topic above the following information is known based on the Sparkplug topic definition:

* The ‘Group ID’ of this device is: Sparkplug B Devices
* The host ‘EoN node ID’ of this device is: Raspberry Pi
* The ‘Device ID’ is: Pibrella
* This is an DBIRTH message from the device

Consider the following Sparkplug B payload in the DBIRTH message shown above:

----
{
        "timestamp": 1486144502122,
        "metrics": [{
                "name": "Inputs/A",
                "timestamp": 1486144502122,
                "dataType": "Boolean",
                "value": false
        }, {
                "name": "Inputs/B",
                "timestamp": 1486144502122,
                "dataType": "Boolean",
                "value": false
        }, {
                "name": "Inputs/C",
                "timestamp": 1486144502122,
                "dataType": "Boolean",
                "value": false
        }, {
                "name": "Inputs/D",
                "timestamp": 1486144502122,
                "dataType": "Boolean",
                "value": false
        }, {
                "name": "Inputs/Button",
                "timestamp": 1486144502122,
                "dataType": "Boolean",
                "value": false
        }, {
                "name": "Outputs/E",
                "timestamp": 1486144502122,
                "dataType": "Boolean",
                "value": false
        }, {
                "name": "Outputs/F",
                "timestamp": 1486144502122,
                "dataType": "Boolean",
                "value": false
        }, {
                "name": "Outputs/G",
                "timestamp": 1486144502122,
                "dataType": "Boolean",
                "value": false
        }, {
                "name": "Outputs/H",
                "timestamp": 1486144502122,
                "dataType": "Boolean",
                "value": false
        }, {
                "name": "Outputs/LEDs/Green",
                "timestamp": 1486144502122,
                "dataType": "Boolean",
                "value": false
        }, {
                "name": "Outputs/LEDs/Red",
                "timestamp": 1486144502122,
                "dataType": "Boolean",
                "value": false
        }, {
                "name": "Outputs/LEDs/Yellow",
                "timestamp": 1486144502122,
                "dataType": "Boolean",
                "value": false
        }, {
                "name": "Outputs/Buzzer",
                "timestamp": 1486144502122,
                "dataType": "Boolean",
                "value": false
        }, {
                "name": "Properties/Hardware Make",
                "timestamp": 1486144502122,
                "dataType": "String",
                "value": "Pibrella"
        }],
        "seq": 0
}
----

This would result in a structure as follows on the backend system.

image:extracted-media/media/image14.png[image,width=721,height=341]

Figure 10 – Sparkplug B Metric Structure 2

[[payloads_ndata]]
=== NDATA

NDATA messages are used to update the values of any EoN node metrics that were originally published in the 
NBIRTH message. Any time an input changes on the EoN node, a NDATA message should be generated and published 
to the MQTT Server. If multiple metrics on the EoN node change, they can all be included in a single NDATA 
message.

The following is a representation of a simple NDATA message on the topic:

spBv1.0/Sparkplug B Devices/NDATA/Raspberry Pi

In the topic above the following information is known based on the Sparkplug topic definition:

* The ‘Group ID’ of this EoN node is: Sparkplug B Devices
* The ‘EoN node ID’ of this EoN node is: Raspberry Pi
* This is an NDATA message from the EoN node

Consider the following Sparkplug B payload in the NDATA message shown above:

----
{
        "timestamp": 1486144502122,
        "metrics": [{
                "name": "Supply Voltage (V)",
                "timestamp": 1486144502122,
                "dataType": "Float",
                "value": 12.3
        }],
        "seq": 2
}
----

This would result in the backend application updating the value of the Supply Voltage metric.

[[payloads_ddata]]
=== DDATA

DDATA messages are used to update the values of any device metrics that were originally published in the 
DBIRTH message. Any time an input changes on the device, a DDATA message should be generated and published 
to the MQTT Server. If multiple metrics on the device change, they can all be included in a single DDATA 
message.

The following is a representation of a simple DDATA message on the topic:

spBv1.0/Sparkplug B Devices/DDATA/Raspberry Pi/Pibrella

* The ‘Group ID’ of this device is: Sparkplug B Devices
* The host ‘EoN node ID’ of this device is: Raspberry Pi
* The ‘Device ID’ is: Pibrella
* This is an DDATA message from the device

Consider the following Sparkplug B payload in the DDATA message shown above:

----
{
        "timestamp": 1486144502122,
        "metrics": [{
                "name": "Inputs/A",
                "timestamp": 1486144502122,
                "dataType": "Boolean",
                "value": true
        }, {
                "name": "Inputs/C",
                "timestamp": 1486144502122,
                "dataType": "Boolean",
                "value": true
        }],
        "seq": 0
}
----

This would result in the backend application updating the value of the ‘Inputs/A’ metric and ‘Inputs/C’ 
metric.

[[payloads_ncmd]]
=== NCMD

NCMD messages are used by backend applications to write to EoN node outputs and send Node Control commands 
to EoN nodes. Multiple metrics can be supplied in a single NCMD message.

The following is a representation of a simple NCMD message on the topic:

spBv1.0/Sparkplug B Devices/NCMD/Raspberry Pi

* The ‘Group ID’ of this device is: Sparkplug B Devices
* The host ‘EoN node ID’ of this EoN node is: Raspberry Pi
* This is an NCMD message to an EoN node

Consider the following Sparkplug B payload in the NCMD message shown above:

----
{
        "timestamp": 1486144502122,
        "metrics": [{
                "name": "Node Control/Rebirth",
                "timestamp": 1486144502122,
                "dataType": "Boolean",
                "value": true
        }]
}
----

This NCMD payload tells the EoN node to republish its NBIRTH and DBIRTH(s) messages. This can be requested 
if a backend application gets an out of order seq number or if a metric arrives in an NDATA or DDATA message 
that was not provided in the original NBIRTH or DBIRTH messages.

[[payloads_dcmd]]
=== DCMD

DCMD messages are used by backend applications to write to device outputs and send Device Control commands 
to devices. Multiple metrics can be supplied in a single DCMD message.

The following is a representation of a simple DCMD message on the topic:

spBv1.0/Sparkplug B Devices/DCMD/Raspberry Pi/Pibrella

* The ‘Group ID’ of this device is: Sparkplug B Devices
* The host ‘EoN node ID’ of this device is: Raspberry Pi
* The ‘Device ID’ is: Pibrella
* This is an DCMD message from the device

Consider the following Sparkplug B payload in the DCMD message shown above:

----
{
        "timestamp": 1486144502122,
        "metrics": [{
                "name": "Outputs/LEDs/Green",
                "timestamp": 1486144502122,
                "dataType": "Boolean",
                "value": true
        }, {
                "name": "Outputs/LEDs/Yellow",
                "timestamp": 1486144502122,
                "dataType": "Boolean",
                "value": true
        }]
}
----

The DCMD payload tells the EoN node to write true to the attached device’s green and yellow LEDs. As a 
result, the LEDs should turn on and result in a DDATA message back to the MQTT Server after the LEDs are 
successfully turned on.

[[payloads_ndeath]]
=== NDEATH

The NDEATH messages are registered with the MQTT Server in the MQTT CONNECT packet as the LW&T. This is 
used by backend applications to know when an EoN node has lost its MQTT connection with the MQTT Server.

The following is a representation of a NDEATH message on the topic:

spBv1.0/Sparkplug B Devices/NDEATH/Raspberry Pi

* The ‘Group ID’ of this device is: Sparkplug B Devices
* The host ‘EoN node ID’ of this EoN node is: Raspberry Pi
* This is an NDEATH message from the MQTT Server on behalf of an EoN node

Consider the following Sparkplug B payload in the NDEATH message shown above:

----
{
        "timestamp": 1486144502122,
        "metrics": [{
                "name": "bdSeq",
                "timestamp": 1486144502122,
                "dataType": "UInt64",
                "value": 0
        }]
}
----

The payload metric of bdSeq allows a backend application to reconcile this NDEATH with the NBIRTH that 
occurred previously.

[[payloads_ddeath]]
=== DDEATH

The DDEATH messages are published by an EoN node on behalf of an attached device. If the EoN node determines 
that a device is no longer accessible (i.e. it has turned off, stopped responding, etc.) the EoN node 
should publish a DDEATH to denote that device connectivity has been lost.

The following is a representation of a simple DDEATH message on the topic:

spBv1.0/Sparkplug B Devices/DDEATH/Raspberry Pi/Pibrella

* The ‘Group ID’ of this device is: Sparkplug B Devices
* The host ‘EoN node ID’ of this device is: Raspberry Pi
* The ‘Device ID’ is: Pibrella
* This is an DDEATH message from the EoN node on behalf of the device

Consider the following Sparkplug B payload in the DDEATH message shown above:

----
{
        "timestamp": 1486144502122,
        "seq": 123
}
----

A sequence number must be included with the DDEATH messages so the backend application can ensure order of 
messages and maintain the state of the data.

[[payloads_state]]
=== STATE

As noted previously, the STATE messages published by backend application(s) do not use Sparkplug B payloads.
